---
parent: "[[Fleeting MOC]]"
tags:
  - ğŸª´weedy
  - dailyNotes
date: 
draft: false
---
## ä¸€ã€å¼•è¨€

é“¾è¡¨æ˜¯ä¸€ç§éçº¿æ€§æ•°æ®ç»“æ„ï¼Œå„ç§è¯­è¨€ä¸­ç»™é“¾è¡¨åˆ†é…å†…å­˜æ—¶ä¸æ˜¯ä¸€å—æ•´ä½“çš„ï¼Œå¯ä»¥å……åˆ†åˆ©ç”¨ç¢ç‰‡å†…å­˜ã€‚ç›¸å¯¹çº¿æ€§çš„æ•°æ®ç»“æ„ï¼Œé“¾è¡¨å¯¹å¢åŠ å’Œåˆ é™¤èŠ‚ç‚¹æ¯”è¾ƒé«˜æ•ˆï¼Œå¯¹è¯»èŠ‚ç‚¹æ•ˆç‡ä½ä¸€äº›ã€‚å¦å¤–éçº¿æ€§ç»“æ„éœ€è¦ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå†…å­˜å ç”¨ä¼šå¤§ä¸€äº›ã€‚

## äºŒã€ é«˜é¢‘é¢è¯•é¢˜

* åè½¬é“¾è¡¨
```java

/**  
 * éé€’å½’æ–¹å¼åè½¬é“¾è¡¨head åˆ° endï¼Œä¸åŒ…æ‹¬ end  
 * @param head  
 * @param end: ä¸åŒ…æ‹¬  
 * @return  
 */  
public static ListNode reverse1(ListNode head, ListNode end) {  
    if(head == end || head.getNext() == end) return head;  
  
    ListNode pre = null;  
    ListNode cur = head;  
    while(cur != end) {  
        ListNode next = cur.getNext();  
        cur.setNext(pre);  
        pre = cur;  
        cur = next;  
    }  
  
    return pre;  
}

/**  
 * é€’å½’æ–¹å¼åè½¬é“¾è¡¨  
 * @param head  
 * @return  
 */  
public static ListNode reverse2(ListNode head) {  
    if(head == null || head.getNext() == null) return head;  
  
    ListNode next = head.getNext();  
    ListNode newHead = reverse2(next);  
    next.setNext(head);  
    head.setNext(null);  
  
    return newHead;  
}

```

* K ä¸ªä¸€ç»„åè½¬é“¾è¡¨
```java
/**  
 * kä¸ªä¸€ç»„åè½¬é“¾è¡¨ï¼Œä¸è¶³ k ä¸ªæ—¶ä¸åè½¬  
 * @param head  
 * @param k  
 * @return  
 */  
public static ListNode reverseKGroup(ListNode head, int k) {  
    // åŠ å…¥ dummy å¥½è®¡ç®— K ä¸ªèŠ‚ç‚¹  
    ListNode dummy = new ListNode(-1);  
    dummy.setNext(head);  
    ListNode p = dummy;  
    for(int i = 0; i < k; i++) {  
        if(p == null || p.getNext() == null) return head;  
        p = p.getNext();  
    }  
  
    // ç¬¬ 2 ç»„çš„é¦–ä¸ªèŠ‚ç‚¹  
    ListNode next = p.getNext();  
    // g1Headä¸ºç¬¬ 1 ç»„åè½¬åçš„å¤´èŠ‚ç‚¹  
    ListNode g1Head = reverse1(head, next);  
  
    // ä»ç¬¬ 2 ç»„å¼€å§‹ç»§ç»­é€’å½’ï¼Œg2Headä¸ºç¬¬ 2 ç»„åè½¬åçš„å¤´èŠ‚ç‚¹  
    ListNode g2Head = reverseKGroup(next, k);  
    // head ç°åœ¨ä¸ºç¬¬ 1 ç»„çš„å°¾èŠ‚ç‚¹äº†  
    head.setNext(g2Head);  
  
    return g1Head;  
}
```

* æ±‚é“¾è¡¨ä¸­é—´èŠ‚ç‚¹
```java
/**  
 * æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚å¥‡æ•°èŠ‚ç‚¹è¿”å›ä¸­é—´èŠ‚ç‚¹ï¼›å¶æ•°èŠ‚ç‚¹è¿”å› 2 ä¸ªä¸­é—´èŠ‚ç‚¹ä¸­çš„ç¬¬ 2 ä¸ªèŠ‚ç‚¹ï¼Œæœ¬åœºæ™¯ä¸»è¦æ–¹ä¾¿å›æ–‡æ¯”è¾ƒ  
 * 1, 2, 3 è¿”å› 2  
 * 1ï¼Œ2ï¼Œ3ï¼Œ4 è¿”å› 3  
 * @param head  
 * @return  
 */  
public static ListNode findTheMid(ListNode head) {  
    if(head == null) return head;  
  
    ListNode slow = head, fast = head;  
    while(fast != null && fast.getNext() != null) {  
        slow = slow.getNext();  
        fast = fast.getNext().getNext();  
    }  
  
    return slow;  
}
```

* åˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯
```java
/**  
 * é€šè¿‡å¿«æ…¢æŒ‡é’ˆåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯  
 * @param head  
 * @return  
 */  
private static boolean hasCycle(ListNode head) {  
    if(head == null || head.getNext() == null) return false;  
  
    ListNode slow = head, fast = head.getNext().getNext();  
  
    while(fast != null && fast.getNext() != null) {  
        if(slow == fast) return true;  
        slow = slow.getNext();  
        fast = fast.getNext().getNext();  
    }  
  
    return false;  
}	
```

* åˆ¤æ–­é“¾è¡¨æ˜¯å¦æ˜¯å›æ–‡
```java
/**  
 * åˆ¤æ–­ä»¥ head å¼€å¤´çš„é“¾è¡¨èŠ‚ç‚¹æ˜¯å¦æ„æˆå›æ–‡  
 * @param head  
 * @return  
 */  
public static boolean isPalindrome(ListNode head) {  
    // æ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ã€‚å¥‡æ•°èŠ‚ç‚¹è¿”å›ä¸­é—´èŠ‚ç‚¹ï¼›å¶æ•°èŠ‚ç‚¹è¿”å› 2 ä¸ªä¸­é—´èŠ‚ç‚¹ä¸­çš„ç¬¬ 2 ä¸ªèŠ‚ç‚¹  
    ListNode mid = findTheMid(head);  
    // åè½¬ä¸­é—´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹é—´çš„å…ƒç´   
    ListNode newHead = reverseToTheEnd(mid);  
    // é¡ºåºæ¯”è¾ƒå‰å 2 ç»„èŠ‚ç‚¹æ˜¯å¦ä¸€æ ·  
    while(head != null && newHead != null) {  
        if(head.getVal() != newHead.getVal()) return false;  
  
        head = head.getNext();  
        newHead = newHead.getNext();  
    }  
  
    return true;  
}
```

* æ±‚ 2 ä¸ªé“¾è¡¨çš„ç›¸äº¤èŠ‚ç‚¹
```java
/**  
 * æ±‚ 2 ä¸ªé“¾è¡¨çš„ç›¸äº¤èŠ‚ç‚¹ã€‚å¦‚æœä¸å­˜åœ¨çš„è¯è¿”å› null  
 * @param head1  
 * @param head2  
 * @return  
 */  
public static ListNode isIntersect(ListNode head1, ListNode head2) {  
    ListNode p1 = head1;  
    ListNode p2 = head2;  
  
    while(p1 != null && p2 != null) {  
        if(p1 == p2) return p1;  
  
        p1 = p1.getNext();  
        if(p1 == null) p1 = head2;  
  
        p2 = p2.getNext();  
        if(p2 == null) p2 = head1;  
    }  
  
    return null;  
}
```

## ä¸‰ã€æ€»ç»“

1. ä¸ºäº†æŠŠå¯¹å¤´èŠ‚ç‚¹å’Œå…¶ä»–èŠ‚ç‚¹çš„å¤„ç†ç»Ÿä¸€ï¼Œä¸€èˆ¬ä¼šåŠ å…¥dummy èŠ‚ç‚¹ã€‚è¿™æ ·è¾¹ç•Œé€»è¾‘å¤„ç†ä¼šå°‘ä¸€äº›ï¼›
2. é“¾è¡¨ç®—æ³•ä¸­å…³é”®ç‚¹æ˜¯å‰åèŠ‚ç‚¹æŒ‡é’ˆçš„å¤„ç†ï¼Œéœ€è¦é¿å…æ„æˆå¾ªç¯ï¼›
3. å¤šç»ƒã€å¤šæ¨æ¼”ã€‚